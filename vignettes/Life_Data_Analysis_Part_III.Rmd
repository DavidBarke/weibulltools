---
title: "Life Data Analysis Part III - Confidence Intervals for Quantiles and Probabilities"
subtitle: "Beta Binomial and Fisher Confidence Bounds"
author: "Tim-Gunnar Hensel"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_height: 6
    fig_width: 7
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Life Data Analysis Part III - Confidence Intervals for Quantiles and Probabilities}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(weibulltools)

# set.seed() for reproducibility of random sampled id's
set.seed(2905)
```

In this section two types of confidence intervals for quantiles and/or probabilities 
are presented.  
The non-parametric procedure of determining beta-binomial confidence bounds is 
pretty similar to the calculation of Median Ranks [^note1]. A parametric approach is to 
compute normal-approximation confidence intervals using the delta method. The obtained
intervals of the latter method are also called Fisher Confidence Bounds. 

which is descrDie Funktion `confint_betabinom` ist eine nicht-parametrische Herangehensweise, um die Konfidenzintervalle für Quantile und/oder Ausfallwahrscheinlichkeiten zu berechnen. Dafür wird ein Verfahren verwendet, das dem zum Berechnen der Median-Ränge ähnlich ist. Außerdem werden die Lage-Skalen-Parameter, die mithilfe der [Median-Rang-Regression](#rank-regression) geschätzt wurden, benötigt. Der Output der Funktion ist ein Dataframe, der die Lebensdauern, die interpolierten Ränge als Funktion der Wahrscheinlichkeiten, die Wahrscheinlichkeiten, die verwendet werden, um die Ränge zu berechnen, und die berechneten Werte für die spezifizierten Konfidenzintervalle enthält.


### Fisher Confidence Bounds
```{r ML estimation Log-normal, message = FALSE}
# Data: 
cycles <- c(300, 300, 300, 300, 300, 291, 274, 271, 269, 257, 256, 227, 226,
            224, 213, 211, 205, 203, 197, 196, 190, 189, 188, 187, 184, 180,
            180, 177, 176, 173, 172, 171, 170, 170, 169, 168, 168, 162, 159,
            159, 159, 159, 152, 152, 149, 149, 144, 143, 141, 141, 140, 139,
            139, 136, 135, 133, 131, 129, 123, 121, 121, 118, 117, 117, 114,
            112, 108, 104, 99, 99, 96, 94)
state <- c(rep(0, 5), rep(1, 67))
id <- 1:length(cycles)

df_john <- johnson_method(x = cycles, event = state, id = id)

# Three-parameter lognormal:  
dists <- "weibull3"
ml_lognormal3 <- ml_estimation(x = df_john$characteristic, event = df_john$status, 
                            distribution = dists)

conf_fish <- confint_fisher(x = df_john$characteristic, event = df_john$status,
                            loc_sc_params = ml_lognormal3$loc_sc_coefficients,
                            loc_sc_varcov = ml_lognormal3$loc_sc_vcov,
                            distribution = dists,
                            bounds = "two_sided",
                            conf_level = 0.95,
                            direction = "y")

plot_lognormal <- plot_prob(x = df_john$characteristic,
                          y = df_john$prob,
                          event = df_john$status,
                          id = df_john$id,
                          distribution = "weibull",
                          title_main = "Three-Parametric Lognormal",
                          title_x = "Cycles",
                          title_y = "Probability of Failure in %",
                          title_trace = "Failed Items")

plot_reg_lognormal <- plot_mod(p_obj = plot_lognormal,
                             x = conf_fish$characteristic,
                             y = conf_fish$prob,
                             loc_sc_params = ml_lognormal3$loc_sc_coefficients,
                             distribution = dists,
                             title_trace = "Estimated Lognormal CDF")

plot_conf_lognormal <- plot_conf(p_obj = plot_reg_lognormal,
                            x = list(conf_fish$characteristic),
                            y = list(conf_fish$lower_bound, conf_fish$upper_bound),
                            direction = "y",
                            distribution = dists,
                            title_trace = "Confidence Region")
plot_conf_lognormal
```
<br> 
The two model selection criteria `aic` and `bic` are smaller for `lognormal3` meaning
that this model is preferable.  

```{r ML visualization I, fig.cap = "Figure 3: Three-parametric Log-normal distribution.", message = FALSE}
# Constructing probability plot: 
# df_alloy <- johnson_method(x = cycles, event = state, id = id)
# lognormal_grid <- plot_prob(x = df_alloy$characteristic, y = df_alloy$prob, 
#                             event = df_alloy$status, id = df_alloy$id, 
#                             distribution = "lognormal", 
#                             title_main = "Log-normal Probability Plot", 
#                             title_x = "Cycles", 
#                             title_y = "Probability of Failure in %",
#                             title_trace = "Failed Units")
# 
# # Add three-parametric model to grid: 
# lognormal_plot <- lognormal_grid %>% 
#   plot_mod(x = df_alloy$characteristic, loc_sc_params = ml_lognormal3$loc_sc_coefficients,
#                              distribution = "lognormal3",
#                              title_trace = "Three-parametric Log-normal")
# lognormal_plot
```

```{r ML visualization II, fig.cap = "Figure 4: Comparison of two- and three-parametric Log-normal distribution.", message = FALSE}
# Add two-parametric model to lognormal_plot: 
## predict_prob to calculate CDF with ML-parameters:  
# ml_prob_lognormal <- predict_prob(q = seq(85, 325, length.out = 100),
#                         loc_sc_params = ml_lognormal$loc_sc_coefficients,
#                         distribution = "lognormal")
# 
# lognormal_both <- lognormal_plot %>%
#   add_lines(x = seq(85, 325, length.out = 100), y = qnorm(ml_prob_lognormal),
#             name = "Two-parametric Log-normal", color = I("#006400"), hoverinfo = "text",
#             text = ~paste(paste("\u03BC<sub>ML</sub>", ":",
#                                 round(ml_lognormal$loc_sc_coefficients[[1]], digits = 2)),
#                           "<br>", paste("\u03C3<sub>ML</sub>", ":",
#                                         round(ml_lognormal$loc_sc_coefficients[[2]], digits = 2))))
# lognormal_both
```
<br> 
In _Figure 4_ we can see that the data is better described if the three-parametric 
model is used. 
